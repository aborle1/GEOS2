! $Id$
!
! Earth System Modeling Framework
! Copyright 2002-2012, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
#define ESMF_FILENAME "ESMF_Attribute.F90"
!==============================================================================
!
! ESMF Attribute Module
!
! (all lines between the !BOP and !EOP markers will be included in the
! automated document processing.)
!------------------------------------------------------------------------------
! one blank line for protex processing - in case all routines here are
! marked internal (BOPI/EOPI), the output file will still have contents.
!BOP
!EOP
!------------------------------------------------------------------------------
! module definition
module ESMF_AttributeMod
!
!------------------------------------------------------------------------------
! INCLUDES
#include "ESMF.h"
#ifndef ESMF_NO_INTEGER_1_BYTE
#define ESMF_NO_INTEGER_1_BYTE
#endif
#ifndef ESMF_NO_INTEGER_2_BYTE
#define ESMF_NO_INTEGER_2_BYTE
#endif
!==============================================================================
!BOPI
! !MODULE: ESMF_AttributeMod - Attribute API
!
! !DESCRIPTION:
!
! The code in this file implements the Attribute defined type
! and functions. This is an
! interface to the actual C++ Attribute class implementation
! in the ../../Infrastructure/Attribute dir.
!
! See the ESMF Developers Guide document for more details.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_BaseMod
  use ESMF_UtilTypesMod ! ESMF utility types
  use ESMF_InitMacrosMod ! ESMF initializer macros
  use ESMF_LogErrMod ! ESMF error handling
  use ESMF_ArrayMod
  Use ESMF_ArrayBundleMod
  use ESMF_CompMod
  use ESMF_CplCompMod
  use ESMF_GridCompMod
  use ESMF_DistGridMod
  use ESMF_FieldMod
  use ESMF_FieldBundleMod
  use ESMF_GridMod
  use ESMF_StateTypesMod
  use ESMF_StateVaMod
  use ESMF_StateMod
  use ESMF_VMMod
  implicit none
!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private
!------------------------------------------------------------------------------
! ! ESMF_Attribute
!
!------------------------------------------------------------------------------
  type ESMF_Attribute
  sequence
    character(len=ESMF_MAXSTR) :: attr_name
    type(ESMF_DataValue) :: attr_value
  end type
!------------------------------------------------------------------------------
!
! !DESCRIPTION:
! The following routines apply to {\tt ESMF\_Array}, {\tt ESMF\_ArrayBundle},
! {\ESMF_DistGrid}, {\tt ESMF\_Field},{\tt ESMF\_FieldBundle}, {\tt ESMF\_Grid},
! and {\tt ESMF\_State}.
!
! !PUBLIC MEMBER FUNCTIONS:
!
! Classes
      public ESMF_Attribute
! Attribute methods
      public ESMF_AttributeAdd
      public ESMF_AttributeCopy
      public ESMF_AttributeRemove
      public ESMF_AttributeGet
      public ESMF_AttributeLink
      public ESMF_AttributeLinkRemove
      public ESMF_AttributeSet
      public ESMF_AttributeUpdate
      public ESMF_AttributeRead
      public ESMF_AttributeWrite
!EOPI
!------------------------------------------------------------------------------
! leave the following line as-is; it will insert the cvs ident string
! into the object file for tracking purposes.
      character(*), parameter, private :: version = &
               '$Id$'
!------------------------------------------------------------------------------
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd - Create Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeAdd
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttAddPackCst
        module procedure ESMF_ArrayAttAddPackCstN
        module procedure ESMF_ArrayAttAddPackCstN1
        module procedure ESMF_ArrayAttAddPackStd
        module procedure ESMF_ArrayBundleAttAddPackCst
        module procedure ESMF_ArrayBundleAttAddPackCstN
        module procedure ESMF_ArrayBundleAttAddPackCstN1
        module procedure ESMF_ArrayBundleAttAddPackStd
        module procedure ESMF_CplCompAttAddPackStd
        module procedure ESMF_CplCompAttAddPackStdN
        module procedure ESMF_CplCompAttAddPackCst
        module procedure ESMF_CplCompAttAddPackCstN
        module procedure ESMF_CplCompAttAddPackCstN1
        module procedure ESMF_GridCompAttAddPackStd
        module procedure ESMF_GridCompAttAddPackStdN
        module procedure ESMF_GridCompAttAddPackCst
        module procedure ESMF_GridCompAttAddPackCstN
        module procedure ESMF_GridCompAttAddPackCstN1
        module procedure ESMF_DistGridAttAddPackCst
        module procedure ESMF_DistGridAttAddPackCstN
        module procedure ESMF_DistGridAttAddPackCstN1
        module procedure ESMF_FieldAttAddPackStd
        module procedure ESMF_FieldAttAddPackCst
        module procedure ESMF_FieldAttAddPackCstN
        module procedure ESMF_FieldAttAddPackCstN1
        module procedure ESMF_FieldBundleAttAddPackCst
        module procedure ESMF_FieldBundleAttAddPackCstN
        module procedure ESMF_FieldBundleAttAddPackCstN1
        module procedure ESMF_GridAttAddPackStd
        module procedure ESMF_GridAttAddPackCst
        module procedure ESMF_GridAttAddPackCstN
        module procedure ESMF_GridAttAddPackCstN1
        module procedure ESMF_StateAttAddPackStd
        module procedure ESMF_StateAttAddPackCst
        module procedure ESMF_StateAttAddPackCstN
        module procedure ESMF_StateAttAddPackCstN1
! !DESCRIPTION:
! This interface provides a single entry point for methods that create
! an Attribute package.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute or hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeCopy
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttCopy
        module procedure ESMF_GridCompAttCopy
        module procedure ESMF_StateAttCopy
! !DESCRIPTION:
! This interface provides a single entry point for methods that copy
! an Attribute or Attribute hierarchy.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRemove
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttRemove
        module procedure ESMF_ArrayBundleAttRemove
        module procedure ESMF_CplCompAttRemove
        module procedure ESMF_GridCompAttRemove
        module procedure ESMF_DistGridAttRemove
        module procedure ESMF_FieldAttRemove
        module procedure ESMF_FieldBundleAttRemove
        module procedure ESMF_GridAttRemove
        module procedure ESMF_StateAttRemove
! !DESCRIPTION:
! This interface provides a single entry point for methods that destroy
! an Attribute or Attribute package.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGet - Get Attributes, Attribute packages, count,
! info, and type
!
! !INTERFACE:
      interface ESMF_AttributeGet
! !PRIVATE MEMBER FUNCTIONS:
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttGetI2 
#endif 
 module procedure ESMF_ArrayAttGetI4 
 module procedure ESMF_ArrayAttGetI8 
 module procedure ESMF_ArrayAttGetR4 
 module procedure ESMF_ArrayAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttGet1DI2 
#endif 
 module procedure ESMF_ArrayAttGet1DI4 
 module procedure ESMF_ArrayAttGet1DI8 
 module procedure ESMF_ArrayAttGet1DR4 
 module procedure ESMF_ArrayAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayAttGetLgcl
        module procedure ESMF_ArrayAttGetLgclList
        module procedure ESMF_ArrayAttGetChar
        module procedure ESMF_ArrayAttGetCharList
        module procedure ESMF_ArrayAttGetInfoByNam
        module procedure ESMF_ArrayAttGetInfoByNum
        module procedure ESMF_ArrayAttGetCount
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttGetI2 
#endif 
 module procedure ESMF_ArrayBundleAttGetI4 
 module procedure ESMF_ArrayBundleAttGetI8 
 module procedure ESMF_ArrayBundleAttGetR4 
 module procedure ESMF_ArrayBundleAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttGet1DI2 
#endif 
 module procedure ESMF_ArrayBundleAttGet1DI4 
 module procedure ESMF_ArrayBundleAttGet1DI8 
 module procedure ESMF_ArrayBundleAttGet1DR4 
 module procedure ESMF_ArrayBundleAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayBundleAttGetLgcl
        module procedure ESMF_ArrayBundleAttGetLgclList
        module procedure ESMF_ArrayBundleAttGetChar
        module procedure ESMF_ArrayBundleAttGetCharList
        module procedure ESMF_ArrayBundleAttGetInfoByNam
        module procedure ESMF_ArrayBundleAttGetInfoByNum
        module procedure ESMF_ArrayBundleAttGetCount
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttGetI2 
#endif 
 module procedure ESMF_CplCompAttGetI4 
 module procedure ESMF_CplCompAttGetI8 
 module procedure ESMF_CplCompAttGetR4 
 module procedure ESMF_CplCompAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttGet1DI2 
#endif 
 module procedure ESMF_CplCompAttGet1DI4 
 module procedure ESMF_CplCompAttGet1DI8 
 module procedure ESMF_CplCompAttGet1DR4 
 module procedure ESMF_CplCompAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_CplCompAttGetLgcl
        module procedure ESMF_CplCompAttGetLgclList
        module procedure ESMF_CplCompAttGetChar
        module procedure ESMF_CplCompAttGetCharList
        module procedure ESMF_CplCompAttGetInfoByNam
        module procedure ESMF_CplCompAttGetInfoByNum
        module procedure ESMF_CplCompAttGetCount
        module procedure ESMF_CplCompAttGetAPinstNames
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttGetI2 
#endif 
 module procedure ESMF_GridCompAttGetI4 
 module procedure ESMF_GridCompAttGetI8 
 module procedure ESMF_GridCompAttGetR4 
 module procedure ESMF_GridCompAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttGet1DI2 
#endif 
 module procedure ESMF_GridCompAttGet1DI4 
 module procedure ESMF_GridCompAttGet1DI8 
 module procedure ESMF_GridCompAttGet1DR4 
 module procedure ESMF_GridCompAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridCompAttGetLgcl
        module procedure ESMF_GridCompAttGetLgclList
        module procedure ESMF_GridCompAttGetChar
        module procedure ESMF_GridCompAttGetCharList
        module procedure ESMF_GridCompAttGetInfoByNam
        module procedure ESMF_GridCompAttGetInfoByNum
        module procedure ESMF_GridCompAttGetCount
        module procedure ESMF_GridCompAttGetAPinstNames
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttGetI2 
#endif 
 module procedure ESMF_DistGridAttGetI4 
 module procedure ESMF_DistGridAttGetI8 
 module procedure ESMF_DistGridAttGetR4 
 module procedure ESMF_DistGridAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttGet1DI2 
#endif 
 module procedure ESMF_DistGridAttGet1DI4 
 module procedure ESMF_DistGridAttGet1DI8 
 module procedure ESMF_DistGridAttGet1DR4 
 module procedure ESMF_DistGridAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_DistGridAttGetLgcl
        module procedure ESMF_DistGridAttGetLgclList
        module procedure ESMF_DistGridAttGetChar
        module procedure ESMF_DistGridAttGetCharList
        module procedure ESMF_DistGridAttGetInfoByNam
        module procedure ESMF_DistGridAttGetInfoByNum
        module procedure ESMF_DistGridAttGetCount
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttGetI2 
#endif 
 module procedure ESMF_FieldAttGetI4 
 module procedure ESMF_FieldAttGetI8 
 module procedure ESMF_FieldAttGetR4 
 module procedure ESMF_FieldAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttGet1DI2 
#endif 
 module procedure ESMF_FieldAttGet1DI4 
 module procedure ESMF_FieldAttGet1DI8 
 module procedure ESMF_FieldAttGet1DR4 
 module procedure ESMF_FieldAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldAttGetLgcl
        module procedure ESMF_FieldAttGetLgclList
        module procedure ESMF_FieldAttGetChar
        module procedure ESMF_FieldAttGetCharList
        module procedure ESMF_FieldAttGetInfoByNam
        module procedure ESMF_FieldAttGetInfoByNum
        module procedure ESMF_FieldAttGetCount
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttGetI2 
#endif 
 module procedure ESMF_FieldBundleAttGetI4 
 module procedure ESMF_FieldBundleAttGetI8 
 module procedure ESMF_FieldBundleAttGetR4 
 module procedure ESMF_FieldBundleAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttGet1DI2 
#endif 
 module procedure ESMF_FieldBundleAttGet1DI4 
 module procedure ESMF_FieldBundleAttGet1DI8 
 module procedure ESMF_FieldBundleAttGet1DR4 
 module procedure ESMF_FieldBundleAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldBundleAttGetLgcl
        module procedure ESMF_FieldBundleAttGetLgclList
        module procedure ESMF_FieldBundleAttGetChar
        module procedure ESMF_FieldBundleAttGetCharList
        module procedure ESMF_FieldBundleAttGetInfoByNam
        module procedure ESMF_FieldBundleAttGetInfoByNum
        module procedure ESMF_FieldBundleAttGetCount
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttGetI2 
#endif 
 module procedure ESMF_GridAttGetI4 
 module procedure ESMF_GridAttGetI8 
 module procedure ESMF_GridAttGetR4 
 module procedure ESMF_GridAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttGet1DI2 
#endif 
 module procedure ESMF_GridAttGet1DI4 
 module procedure ESMF_GridAttGet1DI8 
 module procedure ESMF_GridAttGet1DR4 
 module procedure ESMF_GridAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridAttGetLgcl
        module procedure ESMF_GridAttGetLgclList
        module procedure ESMF_GridAttGetChar
        module procedure ESMF_GridAttGetCharList
        module procedure ESMF_GridAttGetInfoByNam
        module procedure ESMF_GridAttGetInfoByNum
        module procedure ESMF_GridAttGetCount
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttGetI2 
#endif 
 module procedure ESMF_StateAttGetI4 
 module procedure ESMF_StateAttGetI8 
 module procedure ESMF_StateAttGetR4 
 module procedure ESMF_StateAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttGet1DI2 
#endif 
 module procedure ESMF_StateAttGet1DI4 
 module procedure ESMF_StateAttGet1DI8 
 module procedure ESMF_StateAttGet1DR4 
 module procedure ESMF_StateAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_StateAttGetLgcl
        module procedure ESMF_StateAttGetLgclList
        module procedure ESMF_StateAttGetChar
        module procedure ESMF_StateAttGetCharList
        module procedure ESMF_StateAttGetInfoByNam
        module procedure ESMF_StateAttGetInfoByNum
        module procedure ESMF_StateAttGetCount
! !DESCRIPTION:
! This interface provides a single entry point for methods that retrieve
! Attributes.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLink - Link Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLink
! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkArray
        module procedure ESMF_CplCompAttLinkCplComp
        module procedure ESMF_CplCompAttLinkGridComp
        module procedure ESMF_CplCompAttLinkState
        module procedure ESMF_FieldBundleAttLinkField
        module procedure ESMF_FieldBundleAttLinkGrid
        module procedure ESMF_FieldAttLinkGrid
        module procedure ESMF_GridCompAttLinkCplComp
        module procedure ESMF_GridCompAttLinkGridComp
        module procedure ESMF_GridCompAttLinkState
        module procedure ESMF_StateAttLinkArrayBundle
        module procedure ESMF_StateAttLinkArray
        module procedure ESMF_StateAttLinkFieldBundle
        module procedure ESMF_StateAttLinkField
        module procedure ESMF_StateAttLinkState
! !DESCRIPTION:
! This interface provides a single entry point for methods that link
! Attribute hierarchies.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLinkRemove
! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkRmArray
        module procedure ESMF_CplCompAttLinkRmCplComp
        module procedure ESMF_CplCompAttLinkRmGridComp
        module procedure ESMF_CplCompAttLinkRmState
        module procedure ESMF_FieldBundleAttLinkRmField
        module procedure ESMF_FieldBundleAttLinkRmGrid
        module procedure ESMF_FieldAttLinkRmGrid
        module procedure ESMF_GridCompAttLinkRmCplComp
        module procedure ESMF_GridCompAttLinkRmGridComp
        module procedure ESMF_GridCompAttLinkRmState
        module procedure ESMF_StateAttLinkRmArrayBundle
        module procedure ESMF_StateAttLinkRmArray
        module procedure ESMF_StateAttLinkRmFieldBundle
        module procedure ESMF_StateAttLinkRmField
        module procedure ESMF_StateAttLinkRmState
! !DESCRIPTION:
! This interface provides a single entry point for methods that unlink
! Attribute hierarchies.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRead - Read an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRead
! !PRIVATE MEMBER FUNCTIONS:
! TODO
! module procedure ESMF_ArrayAttRead
! module procedure ESMF_ArrayBundleAttRead
        module procedure ESMF_CplCompAttRead
        module procedure ESMF_GridCompAttRead
! module procedure ESMF_DistGridAttRead
        module procedure ESMF_FieldAttRead
        module procedure ESMF_FieldBundleAttRead
        module procedure ESMF_GridAttRead
        module procedure ESMF_StateAttRead
! !DESCRIPTION:
! This interface provides a single entry point for methods that read
! an Attribute or Attribute package.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeSet - Set Attributes and Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeSet
! !PRIVATE MEMBER FUNCTIONS:
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttSetI2 
#endif 
 module procedure ESMF_ArrayAttSetI4 
 module procedure ESMF_ArrayAttSetI8 
 module procedure ESMF_ArrayAttSetR4 
 module procedure ESMF_ArrayAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttSet1DI2 
#endif 
 module procedure ESMF_ArrayAttSet1DI4 
 module procedure ESMF_ArrayAttSet1DI8 
 module procedure ESMF_ArrayAttSet1DR4 
 module procedure ESMF_ArrayAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayAttSetLgcl
        module procedure ESMF_ArrayAttSetLgclList
        module procedure ESMF_ArrayAttSetChar
        module procedure ESMF_ArrayAttSetCharList
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttSetI2 
#endif 
 module procedure ESMF_ArrayBundleAttSetI4 
 module procedure ESMF_ArrayBundleAttSetI8 
 module procedure ESMF_ArrayBundleAttSetR4 
 module procedure ESMF_ArrayBundleAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttSet1DI2 
#endif 
 module procedure ESMF_ArrayBundleAttSet1DI4 
 module procedure ESMF_ArrayBundleAttSet1DI8 
 module procedure ESMF_ArrayBundleAttSet1DR4 
 module procedure ESMF_ArrayBundleAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayBundleAttSetLgcl
        module procedure ESMF_ArrayBundleAttSetLgclList
        module procedure ESMF_ArrayBundleAttSetChar
        module procedure ESMF_ArrayBundleAttSetCharList
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttSetI2 
#endif 
 module procedure ESMF_CplCompAttSetI4 
 module procedure ESMF_CplCompAttSetI8 
 module procedure ESMF_CplCompAttSetR4 
 module procedure ESMF_CplCompAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttSet1DI2 
#endif 
 module procedure ESMF_CplCompAttSet1DI4 
 module procedure ESMF_CplCompAttSet1DI8 
 module procedure ESMF_CplCompAttSet1DR4 
 module procedure ESMF_CplCompAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_CplCompAttSetLgcl
        module procedure ESMF_CplCompAttSetLgclList
        module procedure ESMF_CplCompAttSetChar
        module procedure ESMF_CplCompAttSetCharList
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttSetI2 
#endif 
 module procedure ESMF_GridCompAttSetI4 
 module procedure ESMF_GridCompAttSetI8 
 module procedure ESMF_GridCompAttSetR4 
 module procedure ESMF_GridCompAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttSet1DI2 
#endif 
 module procedure ESMF_GridCompAttSet1DI4 
 module procedure ESMF_GridCompAttSet1DI8 
 module procedure ESMF_GridCompAttSet1DR4 
 module procedure ESMF_GridCompAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridCompAttSetLgcl
        module procedure ESMF_GridCompAttSetLgclList
        module procedure ESMF_GridCompAttSetChar
        module procedure ESMF_GridCompAttSetCharList
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttSetI2 
#endif 
 module procedure ESMF_DistGridAttSetI4 
 module procedure ESMF_DistGridAttSetI8 
 module procedure ESMF_DistGridAttSetR4 
 module procedure ESMF_DistGridAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttSet1DI2 
#endif 
 module procedure ESMF_DistGridAttSet1DI4 
 module procedure ESMF_DistGridAttSet1DI8 
 module procedure ESMF_DistGridAttSet1DR4 
 module procedure ESMF_DistGridAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_DistGridAttSetLgcl
        module procedure ESMF_DistGridAttSetLgclList
        module procedure ESMF_DistGridAttSetChar
        module procedure ESMF_DistGridAttSetCharList
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttSetI2 
#endif 
 module procedure ESMF_FieldAttSetI4 
 module procedure ESMF_FieldAttSetI8 
 module procedure ESMF_FieldAttSetR4 
 module procedure ESMF_FieldAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttSet1DI2 
#endif 
 module procedure ESMF_FieldAttSet1DI4 
 module procedure ESMF_FieldAttSet1DI8 
 module procedure ESMF_FieldAttSet1DR4 
 module procedure ESMF_FieldAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldAttSetLgcl
        module procedure ESMF_FieldAttSetLgclList
        module procedure ESMF_FieldAttSetChar
        module procedure ESMF_FieldAttSetCharList
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttSetI2 
#endif 
 module procedure ESMF_FieldBundleAttSetI4 
 module procedure ESMF_FieldBundleAttSetI8 
 module procedure ESMF_FieldBundleAttSetR4 
 module procedure ESMF_FieldBundleAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttSet1DI2 
#endif 
 module procedure ESMF_FieldBundleAttSet1DI4 
 module procedure ESMF_FieldBundleAttSet1DI8 
 module procedure ESMF_FieldBundleAttSet1DR4 
 module procedure ESMF_FieldBundleAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldBundleAttSetLgcl
        module procedure ESMF_FieldBundleAttSetLgclList
        module procedure ESMF_FieldBundleAttSetChar
        module procedure ESMF_FieldBundleAttSetCharList
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttSetI2 
#endif 
 module procedure ESMF_GridAttSetI4 
 module procedure ESMF_GridAttSetI8 
 module procedure ESMF_GridAttSetR4 
 module procedure ESMF_GridAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttSet1DI2 
#endif 
 module procedure ESMF_GridAttSet1DI4 
 module procedure ESMF_GridAttSet1DI8 
 module procedure ESMF_GridAttSet1DR4 
 module procedure ESMF_GridAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridAttSetLgcl
        module procedure ESMF_GridAttSetLgclList
        module procedure ESMF_GridAttSetChar
        module procedure ESMF_GridAttSetCharList
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttSetI2 
#endif 
 module procedure ESMF_StateAttSetI4 
 module procedure ESMF_StateAttSetI8 
 module procedure ESMF_StateAttSetR4 
 module procedure ESMF_StateAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttSet1DI2 
#endif 
 module procedure ESMF_StateAttSet1DI4 
 module procedure ESMF_StateAttSet1DI8 
 module procedure ESMF_StateAttSet1DR4 
 module procedure ESMF_StateAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_StateAttSetLgcl
        module procedure ESMF_StateAttSetLgclList
        module procedure ESMF_StateAttSetChar
        module procedure ESMF_StateAttSetCharList
! !DESCRIPTION:
! This interface provides a single entry point for methods that attach
! Attributes and Attribute packages, and link Attribute hierarchies.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeWrite
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttWrite
        module procedure ESMF_ArrayBundleAttWrite
        module procedure ESMF_CplCompAttWrite
        module procedure ESMF_GridCompAttWrite
        !module procedure ESMF_DistGridAttWrite
        module procedure ESMF_FieldAttWrite
        module procedure ESMF_FieldBundleAttWrite
        module procedure ESMF_GridAttWrite
        module procedure ESMF_StateAttWrite
! !DESCRIPTION:
! This interface provides a single entry point for methods that write
! an Attribute or Attribute package.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeUpdate
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttUpdate
        module procedure ESMF_GridCompAttUpdate
        module procedure ESMF_FieldAttUpdate
        module procedure ESMF_FieldBundleAttUpdate
        module procedure ESMF_StateAttUpdate
! !DESCRIPTION:
! This interface provides a single entry point for methods that update
! an Attribute hierarchy.
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add an ESMF standard Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackStd(<object>, convention, purpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add an ESMF standard Attribute package. See Section~\ref{sec:AttPacks}
! for a description of Attribute packages and their conventions, purposes,
! and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [convention]
! The convention of the new Attribute package
! \item [purpose]
! The purpose of the new Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add an ESMF standard Attribute package, containing nested standard Attribute packages
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackStdN(<object>, convention, purpose, &
! nestConvention, nestPurpose, nestAttPackInstanceCountList, &
! nestAttPackInstanceNameList, nestCount, &
! nestAttPackInstanceNameCount,rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! character (len = *), intent(in) :: nestConvention(:)
! character (len = *), intent(in) :: nestPurpose(:)
! integer, intent(in) :: nestAttPackInstanceCountList(:)
! character (len = *), intent(out) :: nestAttPackInstanceNameList(:)
! integer, intent(in), optional :: nestCount
! integer, intent(out), optional :: nestAttPackInstanceNameCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add an ESMF standard Attribute package which contains a user-specified
! number of nested standard Attribute packages. ESMF generates and returns
! default instance names for the nested Attribute packages. These names
! can be used later to distinguish among multiple nested Attribute
! packages of the same type in calls to {\tt ESMF\_AttributeGet()},
! {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [convention]
! The convention of the new Attribute package
! \item [purpose]
! The purpose of the new Attribute package
! \item [nestConvention]
! The convention(s) of the standard Attribute package(s) around
! which to nest the new Attribute package
! \item [nestPurpose]
! The purpose(s) of the standard Attribute package(s) around
! which to nest the new Attribute package
! \item [nestAttPackInstanceCountList]
! The desired number of nested Attribute package instances for each
! nested (nestConvention, nestPurpose) package type. Note: if only one
! of each nested package type is desired, then the
! {\tt ESMF\_AttributeAdd()} overloaded method
! {\tt ESMF\_AttAddPackStd()} should be used.
! \item [nestAttPackInstanceNameList]
! The name(s) of the nested Attribute package instances, generated
! by ESMF, used to distinguish between multiple instances of the
! same convention and purpose.
! \item [{[nestCount]}]
! The count of the number of nested Attribute package types to add to
! the new Attribute package.
! \item [{[nestAttPackInstanceNameCount]}]
! The number of nested Attribute package instance names.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add a custom Attribute package or modify an existing Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackCst(<object>, convention, purpose, &
! attrList, count, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! character (len=*), intent(in) :: attrList(:)
! integer, intent(in), optional :: count
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add a custom Attribute package to <object>.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [convention]
! The convention of the Attribute package
! \item [purpose]
! The purpose of the Attribute package
! \item [attrList]
! The list of Attribute names to specify the custom Attribute package
! \item [{[count]}]
! The number of Attributes to add to the custom Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add a custom Attribute package with nested Attribute Packages or modify an existing Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackCstN(<object>, convention, purpose, &
! attrList, count, nestConvention, nestPurpose, nestCount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! character (len=*), intent(in), optional :: attrList(:)
! integer, intent(in), optional :: count
! character (len = *), intent(in) :: nestConvention(:)
! character (len = *), intent(in) :: nestPurpose(:)
! integer, intent(in), optional :: nestCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add a custom Attribute package, with one or more nested Attribute
! packages, to <object>. Allows for building full multiple-child Attribute
! hierarchies (multi-child trees).
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [convention]
! The convention of the Attribute package
! \item [purpose]
! The purpose of the Attribute package
! \item [{[attrList]}]
! The list of Attribute names to specify the custom Attribute package
! \item [{[count]}]
! The number of Attributes to add to the custom Attribute package
! \item [nestConvention]
! The convention(s) of the Attribute package(s) around which to nest
! the new Attribute package
! \item [nestPurpose]
! The purpose(s) of the Attribute package(s) around which to nest the
! new Attribute package
! \item [{[nestCount]}]
! The number of nested Attribute packages to add to the custom
! Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add a custom Attribute package with a single nested Atrribute package, or modify an existing Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackCstN1(<object>, convention, purpose, &
! attrList, count, nestConvention, nestPurpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len=*), intent(in) :: convention
! character (len=*), intent(in) :: purpose
! character (len=*), intent(in), optional :: attrList(:)
! integer, intent(in), optional :: count
! character (len=*), intent(in) :: nestConvention
! character (len=*), intent(in) :: nestPurpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add a custom Attribute package, with a single nested Attribute
! package, to <object>. Allows for building single-child Attribute
! hierarchies (single-child trees).
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [convention]
! The convention of the Attribute package
! \item [purpose]
! The purpose of the Attribute package
! \item [{[attrList]}]
! The list of Attribute names to specify the custom Attribute package
! \item [{[count]}]
! The number of Attributes to add to the custom Attribute package
! \item [nestConvention]
! The convention of the Attribute package around which to nest
! the new Attribute package
! \item [nestPurpose]
! The purpose of the Attribute package around which to nest the
! new Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeCopy()
! subroutine ESMF_AttributeCopy(<object1>, <object2>, copyflag, &
! atttreeflag, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! type(ESMF_Copy_Flag), intent(in) :: copyflag
! type(ESMF_AttTreeFlag), intent(in) :: atttreeflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Copy an Attribute hierarchy from <object1> to <object2>.
! Supported values for <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp1
! \item type(ESMF\_GridComp), intent(inout) :: comp1
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp2
! \item type(ESMF\_GridComp), intent(inout) :: comp2
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! NOTE: Copies between different ESMF objects are not possible at this time.
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! An {\tt ESMF} object
! \item [<object2>]
! An {\tt ESMF} object
! \item [copyflag]
! A flag to determine if the copy is to be by reference, value,
! or both. This flag is documented in section \ref{const:copy}.
! \item [atttreeflag]
! A flag to determine if the copy is supposed to descend the
! Attribute hierarchy. This flag is documented in section \ref{const:atttree}.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, <value argument>, &
! <defaultvalue argument>, convention, purpose, &
! attPackInstanceName, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value argument>, see below for supported values
! <defaultvalue argument>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt value} from the <object>, or from an Attribute
! package on the <object>, specified by {\tt convention} and {\tt purpose},
! and optionally {\tt attPackInstanceName}. A {\tt defaultvalue} argument
! may be given if a return code is not desired when the Attribute is not
! found. See Section~\ref{sec:AttPacks} for a description of Attribute
! packages and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for <value argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: value
! \item integer(ESMF\_KIND\_I8), intent(out) :: value
! \item real (ESMF\_KIND\_R4), intent(out) :: value
! \item real (ESMF\_KIND\_R8), intent(out) :: value
! \item logical, intent(out) :: value
! \item character (len = *), intent(out), value
! \end{description}
! Supported values for <defaultvalue argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out), optional :: defaultvalue
! \item integer(ESMF\_KIND\_I8), intent(out), optional :: defaultvalue
! \item real (ESMF\_KIND\_R4), intent(out), optional :: defaultvalue
! \item real (ESMF\_KIND\_R8), intent(out), optional :: defaultvalue
! \item logical, intent(out), optional :: defaultvalue
! \item character (len = *), intent(out), optional :: defaultvalue
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to retrieve
! \item [<value argument>]
! The value of the named Attribute
! \item [{[<defaultvalue argument>]}]
! The default value of the named Attribute
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one of
! multiple Attribute package instances of the same convention and
! purpose, within a nest. If not specified, defaults to the first
! instance.
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, <valueList argument>, &
! <defaultvalueList argument>, convention, purpose, &
! attPackInstanceName, itemCount, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <valueList argument>, see below for supported values
! <defaultvalueList argument>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! integer, intent(out), optional :: itemCount
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute {\tt valueList} from the <object>, or from an
! Attribute package on the <object>, specified by {\tt convention} and
! {\tt purpose}, and optionally {\tt attPackInstanceName}.
! A {\tt defaultvalueList} list argument may be given if
! a return code is not desired when the Attribute is not found.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for <value argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: valueList(:)
! \item integer(ESMF\_KIND\_I8), intent(out) :: valueList(:)
! \item real (ESMF\_KIND\_R4), intent(out) :: valueList(:)
! \item real (ESMF\_KIND\_R8), intent(out) :: valueList(:)
! \item logical, intent(out) :: valueList(:)
! \item character (len = *), intent(out) :: valueList(:)
! \end{description}
! Supported values for <defaultvalue argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out), optional :: defaultvalueList(:)
! \item integer(ESMF\_KIND\_I8), intent(out), optional :: defaultvalueList(:)
! \item real (ESMF\_KIND\_R4), intent(out), optional :: defaultvalueList(:)
! \item real (ESMF\_KIND\_R8), intent(out), optional :: defaultvalueList(:)
! \item logical, intent(out), optional :: defaultvalueList(:)
! \item character (len = *), intent(out), optional :: defaultvalueList(:)
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to retrieve
! \item [<valueList argument>]
! The valueList of the named Attribute
! \item [{[<defaultvalueList argument>]}]
! The default value list of the named Attribute
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one of
! multiple Attribute package instances of the same convention and
! purpose, within a nest. If not specified, defaults to the first
! instance. (Not implemented yet)
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute
! \item [{[isPresent]}]
! A logical flag to tell if this Attribute is present or not
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get the Attribute count
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetCount(<object>, count, attcountflag, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! integer, intent(out) :: count
! type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return the Attribute count for <object>.
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [count]
! The Attribute count for <object>
! \item [{[attcountflag]}]
! The flag to specify which attribute count to return, the
! default is ESMF\_ATTGETCOUNT\_ATTRIBUTE. This flag is documented
! in section \ref{const:attgetcount}.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by name
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetInfoByNam(<object>, name, keywordEnforcer, &
! convention, purpose, &
! attPackInstanceName, typekind, &
! itemCount, isPresent, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
! character (len=*), intent(in), optional :: convention
! character (len=*), intent(in), optional :: purpose
! character (len=*), intent(in), optional :: attPackInstanceName
! type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
! integer, intent(out), optional :: itemCount
! logical, intent(out), optional :: isPresent
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return information associated with the named Attribute,
! including {\tt typekind} and {\tt itemCount}.
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to query
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one of
! multiple Attribute package instances of the same convention and
! purpose, within a nest. (Not implemented yet)
! \item [{[typekind}]]
! The typekind of the Attribute
! \item [{[itemCount]}]
! The number of items in this Attribute
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by index number
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetInfoByNum(<object>, attributeIndex, name, &
! typekind, itemcount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! integer, intent(in) :: attributeIndex
! character (len = *), intent(out) :: name
! type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
! integer, intent(out), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Returns information associated with the indexed Attribute,
! including {\tt name}, {\tt typekind} and {\tt itemCount}. Keep in
! mind that these indexes start from 1, as expected in a Fortran API.
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [attributeIndex]
! The index number of the Attribute to query
! \item [name]
! The name of the Attribute
! \item [{[typekind]}]
! The typekind of the Attribute
! \item [{[itemCount]}]
! The number of items in this Attribute
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute package instance names
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetAPinstNames(<object>, convention, purpose, &
! attPackInstanceNameList, attPackInstanceNameCount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(out) :: attPackInstanceNameList(:)
! integer, intent(out) :: attPackInstanceNameCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Get the Attribute package instance names of the specified convention
! and purpose. Also get the number of such names.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [convention]
! The convention of the Attribute package instances.
! \item [purpose]
! The purpose of the Attribute package instances.
! \item [attPackInstanceNameList]
! The name(s) of the Attribute package instances of the given
! convention and purpose.
! \item [attPackInstanceNameCount]
! The number of Attribute package instance names.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Component Attribute hierarchy to that of a Component or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_CompAttLink(<object1>, <object2>, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt CplComp} or {\tt GridComp} Attribute hierarchy to the
! hierarchy of a {\tt CplComp}, {\tt GridComp}, or {\tt State}.
! Supported values for the <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp1
! \item type(ESMF\_GridComp), intent(inout) :: comp1
! \end{description}
! Supported values for the <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp2
! \item type(ESMF\_GridComp), intent(inout) :: comp2
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! The ``parent'' object in the Attribute hierarchy link
! \item [<object2>]
! The ``child'' object in the Attribute hierarchy link
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a State Attribute hierarchy with the
! hierarchy of a an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_StateAttLink(state, <object>, rc)
!
! !ARGUMENTS:
! type(ESMF\_State), intent(inout) :: state
! <object>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt State} Attribute hierarchy to the hierarchy of
! a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.
! Supported values for the <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [state]
! An {\tt ESMF\_State} object
! \item [<object>]
! The object with which to link hierarchies
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_FieldBundleAttLink(fieldbundle, field, rc)
!
! !ARGUMENTS:
! type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! type(ESMF\_Field), intent(inout) :: field
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt FieldBundle} Attribute hierarchy to the hierarchy of
! a {\tt Field}.
!
! The arguments are:
! \begin{description}
! \item [fieldbundle]
! An {\tt ESMF\_FieldBundle} object
! \item [field]
! An {\tt ESMF\_Field} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Field and Grid Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_FieldAttLink(field, grid, rc)
!
! !ARGUMENTS:
! type(ESMF\_Field), intent(inout) :: field
! type(ESMF\_Grid), intent(inout) :: grid
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt Field} Attribute hierarchy to the hierarchy of
! a {\tt Grid}.
!
! The arguments are:
! \begin{description}
! \item [field]
! An {\tt ESMF\_Field} object
! \item [grid]
! An {\tt ESMF\_Grid} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_ArrayBundleAttLink(arraybundle, array, rc)
!
! !ARGUMENTS:
! type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! type(ESMF\_Array), intent(inout) :: array
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach an {\tt ArrayBundle} Attribute hierarchy to the hierarchy of
! an {\tt Array}.
!
! The arguments are:
! \begin{description}
! \item [arraybundle]
! An {\tt ESMF\_ArrayBundle} object
! \item [array]
! An {\tt ESMF\_Array} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Component Attribute hierarchy from that of a Component or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_CompAttLinkRemove(<object1>, <object2>, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt CplComp} or {\tt GridComp} Attribute hierarchy from the
! hierarchy of a {\tt CplComp}, {\tt GridComp}, or {\tt State}.
! Supported values for the <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp1
! \item type(ESMF\_GridComp), intent(inout) :: comp1
! \end{description}
! Supported values for the <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp2
! \item type(ESMF\_GridComp), intent(inout) :: comp2
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! The ``parent'' object in the Attribute hierarchy link
! \item [<object2>]
! The ``child'' object in the Attribute hierarchy link
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a State Attribute hierarchy with
! the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_StateAttLinkRemove(state, <object>, rc)
!
! !ARGUMENTS:
! type(ESMF\_State), intent(inout) :: state
! <object>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt State} Attribute hierarchy from the hierarchy of
! a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.
! Supported values for the <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [state]
! An {\tt ESMF\_State} object
! \item [<object>]
! The object with which to unlink hierarchies
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_FieldBundleAttLinkRemove(fieldbundle, field, rc)
!
! !ARGUMENTS:
! type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! type(ESMF\_Field), intent(inout) :: field
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt FieldBundle} Attribute hierarchy from the hierarchy of
! a {\tt Field}.
!
! The arguments are:
! \begin{description}
! \item [fieldbundle]
! An {\tt ESMF\_FieldBundle} object
! \item [field]
! An {\tt ESMF\_Field} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Field and Grid Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_FieldAttLinkRemove(field, grid, rc)
!
! !ARGUMENTS:
! type(ESMF\_Field), intent(inout) :: field
! type(ESMF\_Grid), intent(inout) :: grid
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt Field} Attribute hierarchy from the hierarchy of
! a {\tt Grid}.
!
! The arguments are:
! \begin{description}
! \item [field]
! An {\tt ESMF\_Field} object
! \item [grid]
! An {\tt ESMF\_Grid} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_ArrayBundleAttLinkRemove(arraybundle, array, rc)
!
! !ARGUMENTS:
! type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! type(ESMF\_Array), intent(inout) :: array
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach an {\tt ArrayBundle} Attribute hierarchy from the hierarchy of
! an {\tt Array}.
!
! The arguments are:
! \begin{description}
! \item [arraybundle]
! An {\tt ESMF\_ArrayBundle} object
! \item [array]
! An {\tt ESMF\_Array} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRead - Read Attributes from an XML file
! \label{api:AttributeRead}
!
! !INTERFACE:
! subroutine ESMF_AttributeRead(<object>, fileName, schemaFileName, &
! convention, purpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len=*), intent(in), optional :: fileName
! character (len=*), intent(in), optional :: schemaFileName
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Read Attributes for <object> from fileName, whose format is XML.
! schemaFileName format is XSD. If present, the schemaFileName is used to
! validate the contents of fileName. schemaFileName must be specified for
! a fileName containing custom, user-defined Attributes. schemaFileName
! need not be specified for convention and purposes specifying a standard,
! ESMF-supplied Attribute package. If present, the convention and purpose
! specify an Attribute package which is used to filter the reading to just
! those attributes belonging to the Attribute package.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Requires the third party Xerces C++ XML Parser library to be installed,
! v3.1.0 or better. For more details, see the "ESMF Users Guide",
! "Building and Installing the ESMF, Third Party Libraries, Xerces" and
! the website
! \newline
! "http://xerces.apache.org/xerces-c". Also please see the
! section on Attribute I/O,~\ref{io:attributeio}.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array ! not yet implemented
! \item type(ESMF\_ArrayBundle), intent(inout) :: arrayBundle ! not yet implemented
! \item type(ESMF\_CplComp), intent(inout) :: cplComp
! \item type(ESMF\_GridComp), intent(inout) :: gridComp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle ! not yet implemented
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_DistGrid), intent(inout) :: distGrid ! not yet implemented
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! The {\tt ESMF} object onto which the read Attributes will be placed
! \item [{[fileName]}]
! The name of the XML file to read
! \item [{[schemaFileName]}]
! The name of the XSD file to validate the contents of fileName
! \item [{[convention]}]
! The convention of the Attribute package to read
! \item [{[purpose]}]
! The purpose of the Attribute package to read
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute package
!
! !INTERFACE:
! subroutine ESMF_AttributeRemove(<object>, name, convention, purpose, &
! attPackInstanceName, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: name
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Remove an Attribute, or Attribute package on <object>.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [{[name]}]
! The name of the Attribute to remove
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one of
! multiple Attribute package instances of the same convention and
! purpose, within a nest. If not specified, defaults to the first
! instance. (Not implemented yet)
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
! NOTE: An entire Attribute package can be removed by specifying
! {\tt convention} and {\tt purpose} only, without {\tt name}. By specifying
! {\tt convention}, {\tt purpose}, and {\tt name} an Attribute will be removed
! from the corresponding Attribute package, if it exists. An
! Attribute can be removed directly from <object> by specifying
! {\tt name}, without {\tt convention} and {\tt purpose}.
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <value argument>, &
! convention, purpose, attPackInstanceName, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value argument>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and {\tt value},
! and, if in an Attribute package, a {\tt convention} and {\tt purpose},
! and optionally an {\tt attPackInstanceName}.
! See Section~\ref{sec:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for the <value argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in) :: value
! \item integer(ESMF\_KIND\_I8), intent(in) :: value
! \item real (ESMF\_KIND\_R4), intent(in) :: value
! \item real (ESMF\_KIND\_R8), intent(in) :: value
! \item logical, intent(in) :: value
! \item character (len = *), intent(in), :: value
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to set
! \item [<value argument>]
! The value of the Attribute to set
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one of
! multiple Attribute package instances of the same convention and
! purpose, within a nest. If not specified, defaults to the first
! instance.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <valueList argument>, &
! convention, purpose, attPackInstanceName, &
! itemCount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <valueList argument>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len = *), intent(in), optional :: attPackInstanceName
! integer, intent(in), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and a
! {\tt valueList}, with an {\tt itemCount}, and, if in an Attribute
! package, a {\tt convention} and {\tt purpose}, and optionally an
! {\tt attPackInstanceName}. See Section~\ref{sec:AttPacks} for a
! description of Attribute packages and their conventions, purposes,
! and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for the <value argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in) :: valueList(:)
! \item integer(ESMF\_KIND\_I8), intent(in) :: valueList(:)
! \item real (ESMF\_KIND\_R4), intent(in) :: valueList(:)
! \item real (ESMF\_KIND\_R8), intent(in) :: valueList(:)
! \item logical, intent(in) :: valueList(:)
! \item character (len = *), intent(in) :: valueList(:)
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to set
! \item [<valueList argument>]
! The valueList of the Attribute to set
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[attPackInstanceName]}]
! The name of an Attribute package instance, specifying which one of
! multiple Attribute package instances of the same convention and
! purpose, within a nest. If not specified, defaults to the first
! instance. (Not implemented yet)
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
! subroutine ESMF_AttributeUpdate(<object>, vm, rootList, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! type(ESMF_VM), intent(in) :: vm
! integer, intent(in) :: rootList(:)
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Update an Attribute hierarchy during runtime.
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [vm]
! The virtural machine over which this Attribute hierarchy
! should be updated
! \item [rootList]
! The list of ``root'' PETs that are to be used to update
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package
! \label{api:AttributeWrite}
!
! !INTERFACE:
! subroutine ESMF_AttributeWrite(<object>, convention, purpose, &
! attwriteflag, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Write the Attribute package for <object>. The Attribute package defines
! the convention, purpose, and object type of the associated Attributes. Either
! tab-delimited or xml format is acheived by using {\tt attwriteflag}.
! Currently, only ESMF/ESG/CF Field Attribute packages can be written in
! tab-delimited format. See Section~\ref{sec:AttPacks} for a description
! of Attribute packages and their conventions, purposes, and object types.
!
! Writing Attribute XML files is performed with the standard C++ output
! file stream facility.
!
! Note: For an object type of {\tt ESMF\_GridComp}, convention='WaterML',
! purpose='TimeSeries', and
! \newline
! attwriteflag=ESMF\_ATTWRITE\_XML, an XML file
! conforming to a hydrologic standard called WaterML will be written. See
! the following for more information:
!
! \begin{description}
! \item{"http://his.cuahsi.org/wofws.html"}
! \item{"http://www.earthsystemcurator.org/projects/waterml.shtml"}
! \end{description}
!
! An ESMF Use Test Case is available which showcases an example of how
! to write a WaterML file; please see
!
! \begin{description}
! \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/ESMF\_WaterML"}
! \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/README"}
! \end{description}
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[attwriteflag]}]
! The flag to specify which format is desired for the write, the
! default is ESMF\_ATTWRITE\_TAB. This flag is documented in
! section \ref{const:attwrite}.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!-------------------------------------------------------------------------
! Macro versions of the routines
!-------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-------------------------------------------------------------------------
! CplComp
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackStd(comp, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 character (len=*), parameter :: object="comp" 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."GridSpec".and.purpose.eq."General").or. & 
 (convention.eq."CIM".and.purpose.eq."Model Component Simulation Description").or. & 
 (convention.eq."CIM".and.purpose.eq."Inputs Description"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, convention, & 
 purpose, object, localrc) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdN" 
 
!BOPI 
! !IROUTINE: AttAddPackStdN - Add an ESMF standard Attribute package with nested standard Attribute packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackStdN(comp, convention, purpose, & 
 nestConvention, nestPurpose, nestAttPackInstanceCountList, & 
 nestAttPackInstanceNameList, nestCount, & 
 nestAttPackInstanceNameCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, dimension(:), intent(in) :: nestAttPackInstanceCountList 
 character (len = *), dimension(:), intent(out) :: nestAttPackInstanceNameList 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: nestAttPackInstanceNameCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. ESMF generates and 
! returns default instance names for the nested Attribute packages. 
! These names can be used later to distinguish among multiple nested 
! Attribute packages of the same type in calls to 
! {\tt ESMF\_AttributeGet()}, {\tt ESMF\_AttributeSet()}, and 
! {\tt ESMF\_AttributeRemove()}. See Section~\ref{sec:AttPacks} for a 
! description of Attribute packages and their conventions, purposes, 
! and object types. 
! 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. The user specifies the 
! names of the nested Attribute package instances (not yet implemented), 
! or ESMF generates and returns default instance names. These names can 
! be used later to distinguish among multiple nested Attribute packages 
! of the same type in calls to {\tt ESMF\_AttributeGet()}, 
! {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestAttPackInstanceCountList] 
! The desired number of nested Attribute package instances for each 
! nested (nestConvention, nestPurpose) package type. Note: if only one 
! of each nested package type is desired, then the 
! {\tt ESMF\_AttributeAdd()} overloaded method 
! {\tt ESMF\_AttAddPackStd()} should be used. 
! \item [nestAttPackInstanceNameList] 
! The name(s) of the nested Attribute package instances, generated 
! by ESMF, used to distinguish between multiple instances of the 
! same convention and purpose. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute package types to add to 
! the new Attribute package. 
! \item [{[nestAttPackInstanceNameCount]}] 
! The number of nested Attribute package instance names. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k 
 integer :: localNestCount, localNestAPinstNameSize, totalInstances 
 integer :: localNestAPinstNameCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 integer, dimension(size(nestAttPackInstanceNameList)) :: nestAPinstNameLens 
 character(len=(size(nestAttPackInstanceNameList)*len(nestAttPackInstanceNameList))) :: nestAPinstNameString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! TODO: check if (convention, purpose) is standard attpack type 
 ! if so, then check if (nestConvention, nestPurpose) are standard 
 ! children of the parent 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (size(nestAttPackInstanceCountList).ne.size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestAttPackInstanceCountList and nestConvention must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack conv,purp strings and lengths, add up instances 
 j = 1 
 k = 1 
 totalInstances = 0 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 totalInstances = totalInstances + nestAttPackInstanceCountList(i) 
 enddo 
 
 if (totalInstances.gt.size(nestAttPackInstanceNameList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="size(nestAttPackInstanceNameList) not big enough for the number of instances specified in nestAttPackInstanceCountList", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack widths of NameList elements 
 ! TODO: pack actual lengths (len_trim) when implementing name input 
 localNestAPinstNameSize = size(nestAttPackInstanceNameList) 
 do i=1,localNestAPinstNameSize 
 nestAPinstNameLens(i) = len(nestAttPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackCreateStdNest(comp%compp%base, convention, & 
 purpose, object, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, nestAttPackInstanceCountList, & 
 localNestCount, & 
 nestAPinstNameString, nestAPinstNameLens, localNestAPinstNameSize, & 
 localNestAPinstNameCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,localNestAPinstNameCount 
 nestAttPackInstanceNameList(i) = & 
 nestAPinstNameString(j:(j+nestAPinstNameLens(i)-1)) 
 j = j + nestAPinstNameLens(i) 
 enddo 
 
 ! return number of attpack instance names 
 if (present(nestAttPackInstanceNameCount)) then 
 nestAttPackInstanceNameCount = localNestAPinstNameCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackStdN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackCst(comp, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="comp" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(comp%compp%base, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackCstN(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(comp%compp%base, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackCstN1(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_CplCompAttAddPackCstN(comp, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_CplCompAttCopy(comp1, comp2, copyflag, atttreeflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 type(ESMF_Copy_Flag), intent(in) :: copyflag 
 type(ESMF_AttTreeFlag), intent(in) :: atttreeflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! \item [copyflag] 
! A flag to determine if the copy is to be by reference, value, or both 
! \item [atttreeflag] 
! A flag to determine if the copy is supposed to descend the Attribute 
! hierarchy 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeCopy(comp1%compp%base, comp2%compp%base, & 
 copyflag, atttreeflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttCopy 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI1(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI1(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI2(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI2(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetR4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DR4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetR8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DR8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetLgcl(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetLgclList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetChar(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_CplCompAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCharList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCount(comp, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(comp%compp%base, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetInfoByNam(comp, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(comp%compp%base, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetInfoByNum(comp, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 call c_ESMC_AttributeGetInfoNum(comp%compp%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAPinstNames" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetAPinstNames(comp, convention, purpose, & 
 attPackInstanceNameList, attPackInstanceNameCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(out) :: attPackInstanceNameList 
 integer, intent(out) :: attPackInstanceNameCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Get the Attribute package instance names of the specified convention 
! and purpose. Also get the number of such names. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package instances. 
! \item [purpose] 
! The purpose of the Attribute package instances. 
! \item [attPackInstanceNameList] 
! The name(s) of the Attribute package instances of the given 
! convention and purpose. 
! \item [attPackInstanceNameCount] 
! The number of Attribute package instance names. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, APinstNameSize 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens 
 character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! pack widths of NameList elements 
 APinstNameSize = size(attPackInstanceNameList) 
 do i=1,APinstNameSize 
 APinstNameLens(i) = len(attPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackGetAPinstNames(comp%compp%base, & 
 convention, purpose, object, & 
 APinstNameString, APinstNameLens, APinstNameSize, & 
 attPackInstanceNameCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,attPackInstanceNameCount 
 attPackInstanceNameList(i) = & 
 APinstNameString(j:(j+APinstNameLens(i)-1)) 
 j = j + APinstNameLens(i) 
 enddo 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetAPinstNames 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_CplCompAttRead(comp, fileName, schemaFileName, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt comp}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (present(convention) .and. present(purpose)) continue 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(comp%compp%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_CplCompAttRemove(comp, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(comp%compp%base, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(comp%compp%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI1(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI1(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI2(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI2(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI4(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI8(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetR4(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DR4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetR8(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DR8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetLgcl(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetLgclList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetChar(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(comp%compp%base, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(comp%compp%base, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetCharList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="comp" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_CplCompAttUpdate(comp, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_CplCompAttWrite(comp, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(comp%compp%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(comp%compp%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttWrite 

!-------------------------------------------------------------------------
! GridComp
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackStd(comp, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 character (len=*), parameter :: object="comp" 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."GridSpec".and.purpose.eq."General").or. & 
 (convention.eq."CIM".and.purpose.eq."Model Component Simulation Description").or. & 
 (convention.eq."CIM".and.purpose.eq."Inputs Description"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, convention, & 
 purpose, object, localrc) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStdN" 
 
!BOPI 
! !IROUTINE: AttAddPackStdN - Add an ESMF standard Attribute package with nested standard Attribute packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackStdN(comp, convention, purpose, & 
 nestConvention, nestPurpose, nestAttPackInstanceCountList, & 
 nestAttPackInstanceNameList, nestCount, & 
 nestAttPackInstanceNameCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, dimension(:), intent(in) :: nestAttPackInstanceCountList 
 character (len = *), dimension(:), intent(out) :: nestAttPackInstanceNameList 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: nestAttPackInstanceNameCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. ESMF generates and 
! returns default instance names for the nested Attribute packages. 
! These names can be used later to distinguish among multiple nested 
! Attribute packages of the same type in calls to 
! {\tt ESMF\_AttributeGet()}, {\tt ESMF\_AttributeSet()}, and 
! {\tt ESMF\_AttributeRemove()}. See Section~\ref{sec:AttPacks} for a 
! description of Attribute packages and their conventions, purposes, 
! and object types. 
! 
! Add an ESMF standard Attribute package which contains a user-specified 
! number of nested standard Attribute packages. The user specifies the 
! names of the nested Attribute package instances (not yet implemented), 
! or ESMF generates and returns default instance names. These names can 
! be used later to distinguish among multiple nested Attribute packages 
! of the same type in calls to {\tt ESMF\_AttributeGet()}, 
! {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the standard Attribute package type(s) around 
! which to nest the new Attribute package. 
! \item [nestAttPackInstanceCountList] 
! The desired number of nested Attribute package instances for each 
! nested (nestConvention, nestPurpose) package type. Note: if only one 
! of each nested package type is desired, then the 
! {\tt ESMF\_AttributeAdd()} overloaded method 
! {\tt ESMF\_AttAddPackStd()} should be used. 
! \item [nestAttPackInstanceNameList] 
! The name(s) of the nested Attribute package instances, generated 
! by ESMF, used to distinguish between multiple instances of the 
! same convention and purpose. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute package types to add to 
! the new Attribute package. 
! \item [{[nestAttPackInstanceNameCount]}] 
! The number of nested Attribute package instance names. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k 
 integer :: localNestCount, localNestAPinstNameSize, totalInstances 
 integer :: localNestAPinstNameCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 
 integer, dimension(size(nestAttPackInstanceNameList)) :: nestAPinstNameLens 
 character(len=(size(nestAttPackInstanceNameList)*len(nestAttPackInstanceNameList))) :: nestAPinstNameString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! TODO: check if (convention, purpose) is standard attpack type 
 ! if so, then check if (nestConvention, nestPurpose) are standard 
 ! children of the parent 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (size(nestAttPackInstanceCountList).ne.size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestAttPackInstanceCountList and nestConvention must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack conv,purp strings and lengths, add up instances 
 j = 1 
 k = 1 
 totalInstances = 0 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 totalInstances = totalInstances + nestAttPackInstanceCountList(i) 
 enddo 
 
 if (totalInstances.gt.size(nestAttPackInstanceNameList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="size(nestAttPackInstanceNameList) not big enough for the number of instances specified in nestAttPackInstanceCountList", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 ! pack widths of NameList elements 
 ! TODO: pack actual lengths (len_trim) when implementing name input 
 localNestAPinstNameSize = size(nestAttPackInstanceNameList) 
 do i=1,localNestAPinstNameSize 
 nestAPinstNameLens(i) = len(nestAttPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackCreateStdNest(comp%compp%base, convention, & 
 purpose, object, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, nestAttPackInstanceCountList, & 
 localNestCount, & 
 nestAPinstNameString, nestAPinstNameLens, localNestAPinstNameSize, & 
 localNestAPinstNameCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,localNestAPinstNameCount 
 nestAttPackInstanceNameList(i) = & 
 nestAPinstNameString(j:(j+nestAPinstNameLens(i)-1)) 
 j = j + nestAPinstNameLens(i) 
 enddo 
 
 ! return number of attpack instance names 
 if (present(nestAttPackInstanceNameCount)) then 
 nestAttPackInstanceNameCount = localNestAPinstNameCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackStdN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackCst(comp, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="comp" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(comp%compp%base, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackCstN(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(comp%compp%base, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackCstN1(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_GridCompAttAddPackCstN(comp, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_GridCompAttCopy(comp1, comp2, copyflag, atttreeflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 type(ESMF_Copy_Flag), intent(in) :: copyflag 
 type(ESMF_AttTreeFlag), intent(in) :: atttreeflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! \item [copyflag] 
! A flag to determine if the copy is to be by reference, value, or both 
! \item [atttreeflag] 
! A flag to determine if the copy is supposed to descend the Attribute 
! hierarchy 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeCopy(comp1%compp%base, comp2%compp%base, & 
 copyflag, atttreeflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttCopy 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_GridCompAttRemove(comp, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(comp%compp%base, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(comp%compp%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI1(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI1(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI2(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI2(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetR4(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DR4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetR8(comp, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DR8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetLgcl(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetLgclList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetChar(comp, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_GridCompAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCharList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCount(comp, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(comp%compp%base, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetInfoByNam(comp, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(comp%compp%base, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetInfoByNum(comp, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 call c_ESMC_AttributeGetInfoNum(comp%compp%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetAPinstNames" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetAPinstNames(comp, convention, purpose, & 
 attPackInstanceNameList, attPackInstanceNameCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(out) :: attPackInstanceNameList 
 integer, intent(out) :: attPackInstanceNameCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Get the Attribute package instance names of the specified convention 
! and purpose. Also get the number of such names. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the Attribute package instances. 
! \item [purpose] 
! The purpose of the Attribute package instances. 
! \item [attPackInstanceNameList] 
! The name(s) of the Attribute package instances of the given 
! convention and purpose. 
! \item [attPackInstanceNameCount] 
! The number of Attribute package instance names. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, APinstNameSize 
 character(len=*), parameter :: object="comp" 
 integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens 
 character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! pack widths of NameList elements 
 APinstNameSize = size(attPackInstanceNameList) 
 do i=1,APinstNameSize 
 APinstNameLens(i) = len(attPackInstanceNameList(i)) 
 enddo 
 
 call c_ESMC_AttPackGetAPinstNames(comp%compp%base, & 
 convention, purpose, object, & 
 APinstNameString, APinstNameLens, APinstNameSize, & 
 attPackInstanceNameCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! unpack returned attpack instance names 
 j = 1 
 do i=1,attPackInstanceNameCount 
 attPackInstanceNameList(i) = & 
 APinstNameString(j:(j+APinstNameLens(i)-1)) 
 j = j + APinstNameLens(i) 
 enddo 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetAPinstNames 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 linkChange = ESMF_FALSE 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, state%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_GridCompAttRead(comp, fileName, schemaFileName, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt comp}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (present(convention) .and. present(purpose)) continue 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(comp%compp%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttRead 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI1(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI1(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI2(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI2(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI4(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI8(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetR4(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DR4(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetR8(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DR8(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetLgcl(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetLgclList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetChar(comp, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(comp%compp%base, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(comp%compp%base, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetCharList(comp, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="comp" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_GridCompAttUpdate(comp, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_GridCompAttWrite(comp, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(comp%compp%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(comp%compp%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttWrite 

!-------------------------------------------------------------------------
! STATE
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackStd(state, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 character (len=*), parameter :: object="state" 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."GridSpec".and.purpose.eq."General").or. & 
 (convention.eq."CIM".and.purpose.eq."Model Component Simulation Description").or. & 
 (convention.eq."CIM".and.purpose.eq."Inputs Description"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackCreateStandard(state%statep%base, convention, & 
 purpose, object, localrc) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackCst(state, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="state" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(state%statep%base, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(state%statep%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackCstN(state, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="state" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(state%statep%base, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(state%statep%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackCstN1(state, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_StateAttAddPackCstN(state, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_StateAttCopy(state1, state2, copyflag, atttreeflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state1 
 type(ESMF_State), intent(inout) :: state2 
 type(ESMF_Copy_Flag), intent(in) :: copyflag 
 type(ESMF_AttTreeFlag), intent(in) :: atttreeflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! \item [copyflag] 
! A flag to determine if the copy is to be by reference, value, or both 
! \item [atttreeflag] 
! A flag to determine if the copy is supposed to descend the Attribute 
! hierarchy 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 call c_ESMC_AttributeCopy(state1%statep%base, state2%statep%base, & 
 copyflag, atttreeflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttCopy 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI1(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI1(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI2(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI2(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI4(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI4(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI8(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI8(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetR4(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DR4(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetR8(state, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DR8(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetLgcl(state, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetLgclList(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetChar(state, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(state%statep%base, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_StateAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCharList(state, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(state%statep%base, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCount(state, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(state%statep%base, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetInfoByNam(state, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(state%statep%base, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetInfoByNum(state, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 call c_ESMC_AttributeGetInfoNum(state%statep%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkArray(state, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "array" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state%statep%base, & 
 array, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkArrayBundle(state, arraybundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "array" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state%statep%base, & 
 arraybundle, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkArrayBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkField(state, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state%statep%base, & 
 field%ftypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkFieldBundle(state, fieldbundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state%statep%base, & 
 fieldbundle%this%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkFieldBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkState(state1, state2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state1 
 type(ESMF_State), intent(inout) :: state2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF\_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(state1%statep%base, & 
 state2%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state1%statep%st == ESMF_STATEINTENT_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state1%statep%st == ESMF_STATEINTENT_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmArray(state, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, array, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmArrayBundle(state, arraybundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, arraybundle, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmArrayBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmField(state, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, field%ftypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmFieldBundle(state, fieldbundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, fieldbundle%this%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmFieldBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmState(state1, state2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state1 
 type(ESMF_State), intent(inout) :: state2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 state1%statep%base, state2%statep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_StateAttRemove(state, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(state%statep%base, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(state%statep%base, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(state%statep%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttRemove 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_StateAttRead(state, fileName, schemaFileName, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (present(convention) .and. present(purpose)) continue 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(state%statep%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttRead 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI1(state, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI1(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI2(state, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI2(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI4(state, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI4(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI8(state, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI8(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetR4(state, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DR4(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetR8(state, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DR8(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetLgcl(state, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetLgclList(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetChar(state, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(state%statep%base, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(state%statep%base, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetCharList(state, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="state" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_StateAttUpdate(state, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(state%statep%base, vm, rootList, count, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_StateAttWrite(state, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(state%statep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(state%statep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttWrite 

!-------------------------------------------------------------------------
! FIELDBUNDLE
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldBundleAttAddPackCst(fieldbundle, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="fieldbundle" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(fieldbundle%this%base, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(fieldbundle%this%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldBundleAttAddPackCstN(fieldbundle, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="fieldbundle" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(fieldbundle%this%base, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(fieldbundle%this%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldBundleAttAddPackCstN1(fieldbundle, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_FieldBundleAttAddPackCstN(fieldbundle, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttAddPackCstN1
!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI1(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI1(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI2(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI2(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI4(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI4(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI8(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI8(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetR4(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DR4(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetR8(fieldbundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DR8(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetLgcl(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetLgclList(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetChar(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_FieldBundleAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCharList(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCount(fieldbundle, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(fieldbundle%this%base, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetInfoByNam(fieldbundle, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%this%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(fieldbundle%this%base, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%this%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(fieldbundle%this%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetInfoByNum(fieldbundle, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 call c_ESMC_AttributeGetInfoNum(fieldbundle%this%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldBundleAttLinkField(fieldbundle, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 fieldbundle%this%base, field%ftypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldBundleAttLinkGrid(fieldbundle, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 fieldbundle%this%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldBundleAttLinkRmField(fieldbundle, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 fieldbundle%this%base, field%ftypep%base, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkRmField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldBundleAttLinkRmGrid(fieldbundle, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 fieldbundle%this%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_FieldBundleAttRead(fieldbundle, fileName, schemaFileName, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt fieldbundle}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (present(convention) .and. present(purpose)) continue 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(fieldbundle%this%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_FieldBundleAttRemove(fieldbundle, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(fieldbundle%this%base, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(fieldbundle%this%base, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(fieldbundle%this%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI1(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI1(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI2(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI2(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI4(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI4(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI8(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI8(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetR4(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DR4(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetR8(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DR8(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetLgcl(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetLgclList(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%this%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetChar(fieldbundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(fieldbundle%this%base, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(fieldbundle%this%base, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetCharList(fieldbundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(fieldbundle%this%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_FieldBundleAttUpdate(fieldbundle, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(fieldbundle%this%base, vm, rootList, count, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_FieldBundleAttWrite(fieldbundle, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(fieldbundle%this%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(fieldbundle%this%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttWrite 

!-------------------------------------------------------------------------
! FIELD
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackStd(field, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 character (len=*), parameter :: object="field" 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."GridSpec".and.purpose.eq."General").or. & 
 (convention.eq."CIM".and.purpose.eq."Model Component Simulation Description").or. & 
 (convention.eq."CIM".and.purpose.eq."Inputs Description"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackCreateStandard(field%ftypep%base, convention, & 
 purpose, object, localrc) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackCst(field, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="field" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(field%ftypep%base, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(field%ftypep%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackCstN(field, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="field" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(field%ftypep%base, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(field%ftypep%base, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackCstN1(field, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_FieldAttAddPackCstN(field, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackCstN1
!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI1(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI1(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI2(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI2(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI4(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI4(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI8(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI8(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetR4(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DR4(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetR8(field, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DR8(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetLgcl(field, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetLgclList(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetChar(field, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(field%ftypep%base, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_FieldAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCharList(field, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(field%ftypep%base, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCount(field, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(field%ftypep%base, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetInfoByNam(field, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(field%ftypep%base, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetInfoByNum(field, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 call c_ESMC_AttributeGetInfoNum(field%ftypep%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldAttLinkGrid(field, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 field%ftypep%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldAttLinkRmGrid(field, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 field%ftypep%base, grid, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_FieldAttRead(field, fileName, schemaFileName, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt field}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (present(convention) .and. present(purpose)) continue 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(field%ftypep%base, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_FieldAttRemove(field, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(field%ftypep%base, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(field%ftypep%base, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(field%ftypep%base, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI1(field, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI1(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI2(field, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI2(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI4(field, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI4(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI8(field, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI8(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetR4(field, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DR4(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetR8(field, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DR8(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetLgcl(field, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetLgclList(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetChar(field, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(field%ftypep%base, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(field%ftypep%base, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetCharList(field, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="field" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_FieldAttUpdate(field, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(field%ftypep%base, vm, rootList, count, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_FieldAttWrite(field, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(field%ftypep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(field%ftypep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttWrite 

!-------------------------------------------------------------------------
! ARRAYBUNDLE
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackCst(arraybundle, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="arraybundle" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(arraybundle, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(arraybundle, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackCstN(arraybundle, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="arraybundle" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(arraybundle, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(arraybundle, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackCstN1(arraybundle, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_ArrayBundleAttAddPackCstN(arraybundle, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackStd(arraybundle, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 character (len=*), parameter :: object="arraybundle" 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."GridSpec".and.purpose.eq."General").or. & 
 (convention.eq."CIM".and.purpose.eq."Model Component Simulation Description").or. & 
 (convention.eq."CIM".and.purpose.eq."Inputs Description"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackCreateStandard(arraybundle, convention, & 
 purpose, object, localrc) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_ArrayBundleAttRemove(arraybundle, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(arraybundle, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(arraybundle, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(arraybundle, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI1(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI1(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI2(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI2(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI4(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI4(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI8(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI8(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetR4(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DR4(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetR8(arraybundle, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DR8(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetLgcl(arraybundle, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetLgclList(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetChar(arraybundle, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(arraybundle, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_ArrayBundleAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCharList(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(arraybundle, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCount(arraybundle, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(arraybundle, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetInfoByNam(arraybundle, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(arraybundle, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetInfoByNum(arraybundle, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 call c_ESMC_AttributeGetInfoNum(arraybundle, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_ArrayBundleAttLinkArray(arraybundle, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLink(& 
 arraybundle, array, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttLinkArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_ArrayBundleAttLinkRmArray(arraybundle, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: linkChange 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 linkChange = ESMF_TRUE 
 call c_ESMC_AttributeLinkRemove(& 
 arraybundle, array, linkChange, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttLinkRmArray 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI1(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI1(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI2(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI2(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI4(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI4(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI8(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI8(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetR4(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DR4(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetR8(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DR8(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetLgcl(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetLgclList(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetChar(arraybundle, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(arraybundle, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(arraybundle, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetCharList(arraybundle, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_ArrayBundleAttUpdate(arraybundle, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(arraybundle, vm, rootList, count, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_ArrayBundleAttWrite(arraybundle, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 character(len=*), parameter :: ftarobj="array" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(arraybundle, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(arraybundle, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttWrite 

!-------------------------------------------------------------------------
! ARRAY
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackCst(array, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="array" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(array, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(array, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackCstN(array, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="array" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(array, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(array, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackCstN1(array, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_ArrayAttAddPackCstN(array, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackCstN1
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackStd(array, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An {\tt ESMF_Array} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 character (len=*), parameter :: object="array" 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."GridSpec".and.purpose.eq."General").or. & 
 (convention.eq."CIM".and.purpose.eq."Model Component Simulation Description").or. & 
 (convention.eq."CIM".and.purpose.eq."Inputs Description"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackCreateStandard(array, convention, & 
 purpose, object, localrc) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_ArrayAttRemove(array, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(array, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(array, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(array, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI1(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI1(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI2(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI2(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI4(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI4(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI8(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI8(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetR4(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DR4(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetR8(array, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DR8(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetLgcl(array, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetLgclList(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetChar(array, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(array, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_ArrayAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCharList(array, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(array, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(array, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCount(array, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(array, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetInfoByNam(array, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(array, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(array, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetInfoByNum(array, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 call c_ESMC_AttributeGetInfoNum(array, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetInfoByNum 
 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI1(array, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI1(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI2(array, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI2(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI4(array, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI4(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI8(array, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI8(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetR4(array, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DR4(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetR8(array, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DR8(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetLgcl(array, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetLgclList(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetChar(array, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(array, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(array, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetCharList(array, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="array" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_ArrayAttUpdate(array, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An {\tt ESMF_Array} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(array, vm, rootList, count, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_ArrayAttWrite(array, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 character(len=*), parameter :: ftarobj="array" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(array, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(array, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttWrite 

!-------------------------------------------------------------------------
! GRID
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStd" 
 
!BOPI 
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackStd(grid, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 character (len=*), parameter :: object="grid" 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & 
 (convention.eq."ESMF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."General").or. & 
 (convention.eq."CF".and.purpose.eq."Extended").or. & 
 (convention.eq."GridSpec".and.purpose.eq."General").or. & 
 (convention.eq."CIM".and.purpose.eq."Model Component Simulation Description").or. & 
 (convention.eq."CIM".and.purpose.eq."Inputs Description"))) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & 
 msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 call c_ESMC_AttPackCreateStandard(grid, convention, & 
 purpose, object, localrc) 
 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackCst(grid, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="grid" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(grid, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(grid, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackCstN(grid, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="grid" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(grid, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(grid, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackCstN1(grid, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_GridAttAddPackCstN(grid, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackCstN1
!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI1(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI1(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI2(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI2(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI4(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI4(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI8(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI8(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetR4(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DR4(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetR8(grid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DR8(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetLgcl(grid, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetLgclList(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetChar(grid, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(grid, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_GridAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCharList(grid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(grid, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(grid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCount(grid, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(grid, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetInfoByNam(grid, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(grid, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(grid, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetInfoByNum(grid, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 call c_ESMC_AttributeGetInfoNum(grid, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_GridAttRead(grid, fileName, schemaFileName, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in), optional :: fileName 
 character (len=*), intent(in), optional :: schemaFileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt grid}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! \item [{[fileName]}] 
! The file name to read from. 
! \item [{[schemaFileName]}] 
! The name of the XSD file to validate fileName. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, schemaFileNameLen, localrc 
 
 fileNameLen = 0 
 schemaFileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (present(convention) .and. present(purpose)) continue 
 
 ! get length of given fileNames for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 if (present(schemaFileName)) then 
 schemaFileNameLen = len_trim(schemaFileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(grid, fileNameLen, fileName, & 
 schemaFileNameLen, schemaFileName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_GridAttRemove(grid, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(grid, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(grid, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(grid, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI1(grid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI1(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI2(grid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI2(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI4(grid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI4(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI8(grid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI8(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetR4(grid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DR4(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetR8(grid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DR8(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetLgcl(grid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetLgclList(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetChar(grid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(grid, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(grid, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetCharList(grid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="grid" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_GridAttWrite(grid, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 character(len=*), parameter :: ftarobj="grid" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(grid, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(grid, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttWrite 

!-------------------------------------------------------------------------
! DISTGRID
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCst" 
!BOPI 
! !IROUTINE: AttAddPackCst - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_DistGridAttAddPackCst(distgrid, convention, purpose, & 
 attrList, count, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an existing 
! Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="distgrid" 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 call c_ESMC_AttPackCreateCustom(distgrid, convention, & 
 purpose, object, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(distgrid, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttAddPackCst
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN" 
!BOPI 
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_DistGridAttAddPackCstN(distgrid, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, nestCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), dimension(:), intent(in) :: nestConvention 
 character (len = *), dimension(:), intent(in) :: nestPurpose 
 integer, intent(in), optional :: nestCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with one or more nested 
! Attribute packages, or modify an existing Attribute package. 
! Allows for building full multiple-child Attribute hierarchies 
! (multi-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose(s) of the Attribute package(s) around which to nest the 
! new Attribute package. 
! \item [{[nestCount]}] 
! The count of the number of nested Attribute packages to add to the 
! new Attribute package 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, k, localCount, localNestCount 
 character(len=*), parameter :: object="distgrid" 
 integer, dimension(size(nestConvention)) :: nestConvLens 
 integer, dimension(size(nestPurpose)) :: nestPurpLens 
 character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString 
 character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 localCount = 0 
 if (present(attrList)) then 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 if (count .lt. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="count is negative", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 end if 
 
 if (size(nestConvention).ne.size(nestPurpose)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="number of items in nestConvention and nestPurpose must be the same", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(nestCount)) then 
 if (nestCount > size(nestConvention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & 
 msg="nestCount cannot be larger than size(nestConvention)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 localNestCount = nestCount 
 else 
 localNestCount = size(nestConvention) 
 end if 
 if (localNestCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 k = 1 
 do i=1,localNestCount 
 nestConvLens(i) = len_trim(nestConvention(i)) 
 nestPurpLens(i) = len_trim(nestPurpose(i)) 
 nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) 
 nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) 
 j = j + nestConvLens(i) 
 k = k + nestPurpLens(i) 
 enddo 
 
 call c_ESMC_AttPackNest(distgrid, convention, & 
 purpose, object, localNestCount, nestConvString, nestPurpString, & 
 nestConvLens, nestPurpLens, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (localCount .gt. 0) then 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(distgrid, attrList(i), & 
 convention, purpose, object, localrc) 
 end do 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttAddPackCstN
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstN1" 
!BOPI 
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_DistGridAttAddPackCstN1(distgrid, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in), optional :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in) :: nestConvention 
 character (len = *), intent(in) :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, with a single 
! nested Attribute package, or modify an existing Attribute package. 
! Allows for building single-child Attribute hierarchies 
! (single-child trees). 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [{[attrList]}] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [{[count]}] 
! The count of the number of Attributes to add to the package 
! \item [nestConventio] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(nestConvention)), dimension(1) :: nestConvString 
 character(len=len(nestPurpose)), dimension(1) :: nestPurpString 

 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 nestConvString(1) = nestConvention 
 nestPurpString(1) = nestPurpose 
 
 call ESMF_DistGridAttAddPackCstN(distgrid, convention, purpose, & 
 attrList, count, nestConvString, nestPurpString, 1, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttAddPackCstN1
!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI1(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI1(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI2(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI2(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI4(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI4(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI8(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI8(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetR4(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DR4(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetR8(distgrid, name, value, & 
 defaultvalue, convention, purpose, attPackInstanceName, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DR8(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The real default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 litemcount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetLgcl(distgrid, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack, localvalue 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetLgclList(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The logical default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of values in the Attribute. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 litemCount = size(valueList) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetChar(distgrid, name, value, defaultvalue, & 
 convention, purpose, attPackInstanceName, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [{[defaultvalue]}] 
! The character default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 integer, dimension(1) :: lens 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 

 lens(1) = len(value) 
 count = 1 

 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(distgrid, name, & 
 ESMF_TYPEKIND_CHARACTER, count, lens, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, lens, value, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default value not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_DistGridAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCharList(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, attPackInstanceName, & 
 itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [{[defaultvalueList]}] 
! The character list default value of the named Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The itemCount of the character items to retrieve 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 valueString = "" 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 litemCount = size(valueList) 
 
 do i=1,litemCount 
 lens(i) = len(valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(distgrid, name, & 
 ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(valueList) 
 endif 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 if(present(itemCount)) then 
 itemCount = size(defaultvalueList) 
 endif 
 endif 
 else 
 ! must set itemCount to 0 in this case because it will not have been 
 ! modified from the original size of the given valueList 
 if(present(itemCount)) then 
 itemCount = 0 
 endif 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and default values not given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if(present(itemCount)) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, localTk, & 
 litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCount(distgrid, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(distgrid, count, lattcountflag, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetInfoByNam(distgrid, name, keywordEnforcer, & 
 convention, purpose, attPackInstanceName, & 
 typekind, itemCount, isPresent, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character(len=*), intent(in) :: name 
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 character (len=*), intent(in), optional :: attPackInstanceName 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 logical, intent(out), optional :: isPresent 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[isPresent]}] 
! A logical flag to tell if this Attribute is present or not 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: lisPresent, isAttpack 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 lisPresent = ESMF_FALSE 
 isAttpack = ESMF_FALSE 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 isAttpack = ESMF_TRUE 
 endif 
 
 if (isAttpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, attPackInstanceName, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttPackGetInfoName(distgrid, name, localTk, litemCount, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, lisPresent, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (lisPresent == ESMF_TRUE) then 
 call c_ESMC_AttributeGetInfoName(distgrid, name, & 
 localTk, litemCount, localrc) 
 endif 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(isPresent)) then 
 isPresent = lisPresent 
 endif 
 
 if(lisPresent .eq. ESMF_TRUE) then 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 else 
 if (present(typekind)) typekind = ESMF_NOKIND 
 if (present(itemCount)) itemCount = 0 
 if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & 
 msg="Attribute not found and neither default values nor isPresent flag was given", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetInfoByNum(distgrid, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind_Flag), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! Returns the typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character 
! types, this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind_Flag) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 call c_ESMC_AttributeGetInfoNum(distgrid, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_DistGridAttRemove(distgrid, name, convention, purpose, & 
 attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(distgrid, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(distgrid, name, convention, & 
 purpose, fobject, attPackInstanceName, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(distgrid, name, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI1(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI1(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI2(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI2(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI4(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI4(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI8(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI8(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetR4(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DR4(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetR8(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 integer :: count 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, count, value, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, count, value, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DR8(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetLgcl(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetLgclList(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[itemCount]}] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetChar(distgrid, name, value, convention, & 
 purpose, attPackInstanceName, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 integer, dimension(1) :: lens 
 type(ESMF_Logical) :: attpack 
 integer :: count 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 lens(1) = len_trim(value) 
 count = 1 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
! call c_ESMC_AttPackSetChar(distgrid, name, value, & 
! ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, & 
! attPackInstanceName, localrc) 
 call c_ESMC_AttPackSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
! call c_ESMC_AttributeSetChar(distgrid, name, value, localrc) 
 call c_ESMC_AttributeSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 count, value, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetCharList(distgrid, name, valueList, & 
 convention, purpose, attPackInstanceName, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 character (len = *), intent(in), optional :: attPackInstanceName 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [{[convention]}] 
! The convention of the Attribute package. 
! \item [{[purpose]}] 
! The purpose of the Attribute package. 
! \item [{[attPackInstanceName]}] 
! The name of an Attribute package instance, specifying which one 
! of multiple Attribute package instances of the same convention 
! and purpose, within a nest. If not specified, defaults to the 
! first instance. (Not implemented yet) 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & 
 msg="valueList is too small", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & 
 msg="both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rcToReturn=rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, & 
 attPackInstanceName, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetCharList 

!------------------------------------------------------------------------------
end module ESMF_AttributeMod
